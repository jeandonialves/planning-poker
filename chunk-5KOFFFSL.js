import{W as Z,X as U,Y as y,Z as p,_ as l}from"./chunk-I7AAR3MZ.js";import{A as k,C as d,D as z,F as m,K as $,R as x,T as g,W as O,a as E,c as V,d as T,e as S,f as w,ua as L,va as b,w as j,za as F}from"./chunk-GZVAOUFT.js";var q="firebase",K="10.14.1";p(q,K,"app");var R=new L("ANGULARFIRE2_VERSION"),Ee=e=>`The APP_INITIALIZER that is "making" isSupported() sync for the sake of convenient DI has not resolved in this
context. Rather than injecting ${e} in the constructor, first ensure that ${e} is supported by calling
\`await isSupported()\`, then retrieve the instance from the injector manually \`injector.get(${e})\`.`;function Se(e,t,n){if(t){if(t.length===1)return t[0];let i=t.filter(a=>a.app===n);if(i.length===1)return i[0]}return n.container.getProvider(e).getImmediate({optional:!0})}var Y=(e,t)=>{let n=t?[t]:y(),r=[];return n.forEach(o=>{o.container.getProvider(e).instances.forEach(a=>{r.includes(a)||r.push(a)})}),r},B=class{constructor(){return Y(C)}},C="app-check";function f(){}var v=class{zone;delegate;constructor(t,n=T){this.zone=t,this.delegate=n}now(){return this.delegate.now()}schedule(t,n,r){let o=this.zone,i=function(a){o.runGuarded(()=>{t.apply(this,[a])})};return this.delegate.schedule(i,n,r)}},P=class{zone;task=null;constructor(t){this.zone=t}call(t,n){let r=this.unscheduleTask.bind(this);return this.task=this.zone.run(()=>Zone.current.scheduleMacroTask("firebaseZoneBlock",f,{},f,f)),n.pipe(j({next:r,complete:r,error:r})).subscribe(t).add(r)}unscheduleTask(){setTimeout(()=>{this.task!=null&&this.task.state==="scheduled"&&(this.task.invoke(),this.task=null)},10)}},W=(()=>{class e{ngZone;outsideAngular;insideAngular;constructor(n){this.ngZone=n,this.outsideAngular=n.runOutsideAngular(()=>new v(Zone.current)),this.insideAngular=n.run(()=>new v(Zone.current,V)),globalThis.\u0275AngularFireScheduler||=this}static \u0275fac=function(r){return new(r||e)(z(g))};static \u0275prov=k({token:e,factory:e.\u0275fac,providedIn:"root"})}return e})();function I(){let e=globalThis.\u0275AngularFireScheduler;if(!e)throw new Error(`Either AngularFireModule has not been provided in your AppModule (this can be done manually or implictly using
provideFirebaseApp) or you're calling an AngularFire method outside of an NgModule (which is not supported).`);return e}function Q(e){return I().ngZone.runOutsideAngular(()=>e())}function c(e){return I().ngZone.run(()=>e())}function X(e){return ee(I())(e)}function ee(e){return function(n){return n=n.lift(new P(e.ngZone)),n.pipe(w(e.outsideAngular),S(e.insideAngular))}}var te=(e,t)=>function(){let r=arguments;return t&&setTimeout(()=>{t.state==="scheduled"&&t.invoke()},10),c(()=>e.apply(void 0,r))},H=(e,t)=>function(){let n,r=arguments;for(let i=0;i<arguments.length;i++)typeof r[i]=="function"&&(t&&(n||=c(()=>Zone.current.scheduleMacroTask("firebaseZoneBlock",f,{},f,f))),r[i]=te(r[i],n));let o=Q(()=>e.apply(this,r));if(!t)if(o instanceof E){let i=I();return o.pipe(w(i.outsideAngular),S(i.insideAngular))}else return c(()=>o);return o instanceof E?o.pipe(X):o instanceof Promise?c(()=>new Promise((i,a)=>o.then(s=>c(()=>i(s)),s=>c(()=>a(s))))):typeof o=="function"&&n?function(){return setTimeout(()=>{n&&n.state==="scheduled"&&n.invoke()},10),o.apply(this,arguments)}:c(()=>o)};var h=class{constructor(t){return t}},M=class{constructor(){return y()}};function ne(e){return e&&e.length===1?e[0]:new h(U())}var _=new d("angularfire2._apps"),re={provide:h,useFactory:ne,deps:[[new m,_]]},ie={provide:M,deps:[[new m,_]]};function oe(e){return(t,n)=>{let r=n.get(O);p("angularfire",R.full,"core"),p("angularfire",R.full,"app"),p("angular",b.full,r.toString());let o=t.runOutsideAngular(()=>e(n));return new h(o)}}function Ve(e,...t){return $([re,ie,{provide:_,useFactory:oe(e),multi:!0,deps:[g,x,W,...t]}])}var Te=H(Z,!0);var se="firebase",ae="10.14.1";l.registerVersion(se,ae,"app-compat");var ue=["ngOnDestroy"],We=(e,t,n,r={})=>new Proxy(e,{get:(o,i)=>n.runOutsideAngular(()=>{if(e[i])return r?.spy?.get&&r.spy.get(i,e[i]),e[i];if(ue.indexOf(i)>-1)return()=>{};let a=t.toPromise().then(s=>{let u=s?.[i];return typeof u=="function"?u.bind(s):u?.then?u.then(A=>n.run(()=>A)):n.run(()=>u)});return new Proxy(()=>{},{get:(s,u)=>a[u],apply:(s,u,A)=>a.then(J=>{let N=J?.(...A);return r?.spy?.apply&&r.spy.apply(i,A,N),N})})})});var D=class{constructor(t){return t}},He=new d("angularfire2.app.options"),Ge=new d("angularfire2.app.name");function Je(e,t,n){let r=typeof n=="string"&&n||"[DEFAULT]",o=typeof n=="object"&&n||{};o.name=o.name||r;let a=l.apps.filter(s=>s&&s.name===o.name)[0]||t.runOutsideAngular(()=>l.initializeApp(e,o));try{if(JSON.stringify(e)!==JSON.stringify(a.options)){let s=!!module.hot;ce("error",`${a.name} Firebase App already initialized with different options${s?", you may need to reload as Firebase is not HMR aware.":"."}`)}}catch{}return new D(a)}var ce=(e,...t)=>{F()&&typeof console<"u"&&console[e](...t)};function qe(e,t,n,r,o){let[,i,a]=globalThis.\u0275AngularfireInstanceCache.find(s=>s[0]===e)||[];if(i)return pe(o,a)||(G("error",`${t} was already initialized on the ${n} Firebase App with different settings.${le?" You may need to reload as Firebase is not HMR aware.":""}`),G("warn",{is:o,was:a})),i;{let s=r();return globalThis.\u0275AngularfireInstanceCache.push([e,s,o]),s}}function pe(e,t){try{return e.toString()===t.toString()}catch{return e===t}}var le=typeof module<"u"&&!!module.hot,G=(e,...t)=>{F()&&typeof console<"u"&&console[e](...t)};globalThis.\u0275AngularfireInstanceCache||=[];export{R as a,Ee as b,Se as c,Y as d,B as e,W as f,X as g,H as h,h as i,M as j,Ve as k,Te as l,We as m,He as n,Ge as o,Je as p,qe as q};
